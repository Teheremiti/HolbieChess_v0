<!-- Render template for the chess app -->
<!DOCTYPE html>
<html>
<head>
  <title>Holbie Chess</title>
  <link rel="stylesheet"
    href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
    integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
    crossorigin="anonymous">
<body>
  <div id="board" style="width: 400px"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
        crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
        integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
        crossorigin="anonymous"></script>
  <script>
    var board;
    var game = new Chess();
    var isGameOver = false;

    function onDragStart (source, piece, position, orientation) {
      if (game.in_checkmate() === true || game.in_draw() === true || isGameOver === true ||
          (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
          (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
        return false;
      }
    }

    /*function makeBestMove () {
      $.ajax({
        url: '/move',
        type: 'POST',
        data: {
          move: 'best'
        },
        success: function(response) {
          board.position(game.fen());
          renderMoveHistory(game.history());
          if (response.game_over) {
            isGameOver = true;
            alert('Game over');
          }
        },
        error: function(error) {
          console.log('Error: ' + error.responseText);
        }
      });
    }*/

    /*function renderMoveHistory (moves) {
      var historyElement = $('#move-history').empty();
      historyElement.empty();
      historyElement.html('<span>Move History:</span><br>');

      moves.forEach((move, index) => {
        var moveNumber = Math.floor(index / 2) + 1;
          if (index % 2 === 0) {
      // Display White's move
          historyElement.append('<br>' + moveNumber + '. ' + move);
        } else {
      // Display Black's move
          historyElement.append(' ' + move);
        }
      });
      historyElement.scrollTop(historyElement[0].scrollHeight);
    }*/

    var onDrop = function (source, target) {
      var move = game.move({
        from: source,
        to: target,
        promotion: 'q'
      });

      removeGreySquares();
      if (move === null) return 'snapback';
      //renderMoveHistory(game.history());
      //window.setTimeout(makeBestMove, 250);
    };

    var onSnapEnd = function () {
      board.position(game.fen());
    };

    var removeGreySquares = function () {
      $('#board .square-55d63').css('background', '');
    };

    var greySquare = function (square) {
      var squareEl = $('#board .square-' + square);
      
      var background = '#a9a9a9';
      if (squareEl.hasClass('black-3c85d') === true) {
        background = '#696969';
      }

      squareEl.css('background', background);
    };

    var onDragMove = function (oldPos, newPos) {
      var square = newPos;
      removeGreySquares();
      
      var moves = game.moves({
        square: square,
        verbose: true
      });

      for (var i = 0; i < moves.length; i++) {
        greySquare(moves[i].to);
      }
    };

    board = ChessBoard('board', {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onMouseoutSquare: removeGreySquares,
      onSnapEnd: onSnapEnd,
      onDragMove: onDragMove
    });
  </script>
</body>
</html>
